<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MagmaSender App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .greyed-out {
            opacity: 0.5;
            pointer-events: none;
        }
        .active, .connect-btn {
            opacity: 1;
            pointer-events: auto;
        }
        #walletInfo, #tokenApproval, #tokenTransfer, .connect-btn {
            margin-top: 20px;
        }
        input, textarea, button {
            margin-top: 10px;
            padding: 10px;
            font-size: 16px;
            width: 80%;
            max-width: 500px;
        }
        textarea {
            resize: vertical;
            height: 100px;
        }
        button {
            cursor: pointer;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
</head>
<body>
    <button class="connect-btn" onclick="connectWallet()">Connect Wallet</button>

    <div id="app" class="greyed-out">
        <div id="walletInfo">
            <p id="walletConnected">Wallet Connected: <span id="userAddress">No</span></p>
        </div>
        <div id="tokenApproval">
            <input type="text" id="tokenContractAddress" placeholder="Token Contract Address">
            <input type="number" id="approvalAmount" placeholder="Approval Amount">
            <button onclick="approveToken()">Approve Token</button>
        </div>
        <div id="tokenTransfer">
            <input type="text" id="disperseTokenContractAddress" placeholder="Token Contract Address for Dispersal">
            <textarea id="recipientAddresses" placeholder="Recipient Addresses (comma-separated)"></textarea>
            <input type="number" id="disperseAmount" placeholder="Amount per Recipient">
            <button onclick="disperseTokens()">Disperse Tokens</button>
        </div>
    </div>

    <script>
        const ERC20_ABI = [{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"}];
        const MagmaSender_ABI = [
    {
        "inputs": [
            {"internalType": "contract IERC20", "name": "token", "type": "address"},
            {"internalType": "address[]", "name": "recipients", "type": "address[]"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"}
        ],
        "name": "disperseTokens",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
];

        const app = document.getElementById('app');
        const connectBtn = document.querySelector('.connect-btn');
        const senderContractAddress = "0xc10685ff28e298e72ce3cc7c7ef3306de685326a"; // Replace with your MagmaSender contract address

        async function connectWallet() {
            try {
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                const account = accounts[0];
                app.classList.remove('greyed-out');
                app.classList.add('active');
                connectBtn.classList.add('greyed-out');
                document.getElementById('walletConnected').textContent = `Wallet Connected: ${account}`;
            } catch (error) {
                console.error('Error connecting to MetaMask:', error);
            }
        }

        async function approveToken() {
            const tokenContractAddress = document.getElementById('tokenContractAddress').value.trim();
            const approvalAmount = document.getElementById('approvalAmount').value.trim();

            if (!tokenContractAddress || !approvalAmount) {
                alert("Token contract address and approval amount are required.");
                return;
            }

            try {
                const web3 = new Web3(window.ethereum);
                const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenContractAddress);
                const accounts = await web3.eth.getAccounts();
                const account = accounts[0];
                const amountInWei = web3.utils.toWei(approvalAmount, 'ether');

                await tokenContract.methods.approve(senderContractAddress, amountInWei).send({ from: account });
                alert("Token approval successful.");
            } catch (error) {
                console.error('Error in token approval:', error);
                alert("Token approval failed: " + error.message);
            }
        }

        async function disperseTokens() {
            const tokenContractAddress = document.getElementById('disperseTokenContractAddress').value.trim();
            const recipientList = document.getElementById('recipientAddresses').value.trim();
            const disperseAmount = document.getElementById('disperseAmount').value.trim();
            const recipients = recipientList.split(',').map(address => address.trim());

            if (!tokenContractAddress || recipients.length === 0 || !disperseAmount) {
                alert("Token contract address, recipient addresses, and disperse amount are required.");
                return;
            }

            try {
                const web3 = new Web3(window.ethereum);
                const magmaSenderContract = new web3.eth.Contract(MagmaSender_ABI, senderContractAddress);
                const accounts = await web3.eth.getAccounts();
                const account = accounts[0];
                const amountInWei = web3.utils.toWei(disperseAmount, 'ether');

                await magmaSenderContract.methods.disperseTokens(tokenContractAddress, recipients, amountInWei).send({ from: account });
                alert("Token dispersal successful.");
            } catch (error) {
                console.error('Error in token dispersal:', error);
                alert("Token dispersal failed: " + error.message);
            }
        }

        document.getElementById('recipientAddresses').addEventListener('input', function(e) {
    // Get the current value of the textarea
    var text = e.target.value;

    // Split the pasted content by common delimiters and remove empty entries
    var addresses = text.split(/[\n ,]+/).filter(Boolean);

    // Join the addresses back together as a comma-separated string without spaces
    var formattedAddresses = addresses.join(',');

    // Update the textarea with the formatted addresses
    e.target.value = formattedAddresses;
});

        
    </script>
</body>
</html>
